<?php
/**
 * Created by PhpStorm.
 * User: naomileow
 * Date: 14/11/14
 * Time: 12:23 PM
 */

namespace Phortress\Dephenses\Engine;


use Phortress\Dephenses\Error;
use Phortress\Dephenses\Taint\Annotation;
use Phortress\Dephenses\Taint\StmtAnalyser;
use PhpParser\Node\Arg;
use PhpParser\Node\Expr\FuncCall;

class SQLVulnerabilityFinder extends VulnerabilityFinder{

	protected function getSQLInjectionVulnerableNodes(){
		$sinkCondition = function ($node){
			if($node instanceof FuncCall){
				return \Phortress\Dephenses\Taint\Sinks::isSQLInjectionSinkFunction($node);
			}else{
				return false;
			}
		};
		parent::getNodesToCheck($sinkCondition);
	}

	protected function getVulnerableNodes(){
		if(!empty($this->vulnerableNodes)){
			return $this->vulnerableNodes;
		}else{
			$nodes = $this->getSQLInjectionVulnerableNodes();
			$this->vulnerableNodes = $nodes;
			return $nodes;
		}
	}

	public function findVulnerabilities(){
		if(!empty($this->messages)){
			return $this->messages;
		}else{
			$possible = $this->getVulnerableNodes();
			$messages = array();
			foreach($possible as $node){
				$result = $this->checkVulnerableNode($node);
				if($result >= Annotation::UNKNOWN){
					$message = $this->constructMessage($result, $node);
				}
				$message[] = $result;
			}
			$this->messages = $messages;
			return $messages;
		}

	}

	protected function checkVulnerableNode(FuncCall $funcCall){
		$args = $funcCall->args;
		$max_taint = Annotation::UNASSIGNED;
		foreach($args as $arg){
			$argTaint = $this->resolveAndCheckFunctionArgument($arg);
			$max_taint = max($max_taint, $argTaint);
		}
		return $max_taint;
	}

	private function resolveAndCheckFunctionArgument(Arg $arg){
		$arg_val = $arg->value;
		if($arg_val instanceof Expr){
			return StmtAnalyser::resolveExprTaint($arg_val);
		}else{
			return Annotation::UNKNOWN;
		}
	}

	private function constructMessage($annotation, FuncCall $funcCall){
		$message = "SQL Injection Vulnerability was found in a call to ". $funcCall->name;
		if($annotation == Annotation::UNKNOWN){
			$message = "A possible " . $message;
			return new Message($message, $funcCall);
		}else if($annotation == Annotation::TAINTED){
			$message = "An ". $message;
			return new Error($message, $funcCall);
		}
	}


} 